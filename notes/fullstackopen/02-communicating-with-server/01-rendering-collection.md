#
- Difference between an experienced JavaScript programmer and a rookie?
  The experienced one uses console.log 10-100 times more
- Don't just guess what's wrong. Instead, log or use some other way of debugging
- For debugging, don't concatenate things 'the Java way' with a plus
ðŸ”´ console.log('props value is ' + props) // props value is [object Object]
- When concatenating an object (props) with a string, it converts the object to a string using toString()
ðŸŸ¢ console.log('props value is', props)

JavaScript Arrays:
find() - returns the first element in the array that satisfies the provided testing function
some() - returns true if at least one element in the array meets the condition of the provided function
every() - returns true if all element in the array meets the condition of the provided function
includes() - checks whether an array includes a certain value among its entries, returning true or false as appropriate

Rendering Collections:
- Accessing the objects in the array by referring to a hard-coded index number is not practical
  improve this by generating React elements from the array objects using the map function
`{notes.map(note => <li>{note.content}</li>)}`

Key-attribute:
- The elements generated by the map method, must each have a unique key value: an attribute called key
- React uses the key property to track list items
  When the component re-renders, React checks the keys to see which items changed, were added, or were removed
  This helps React update only the necessary parts of the screen instead of reloading everything
`{notes.map(note => <li key={note.id}>{note.content}</li>)}`

- If there is no unique property in the object, use the index of the array as the key:
- Anti-pattern: Array Indexes as Keys: not recommended
{items.map((item, index) => (
  <li key={index}>{item.name}</li>
))}

Map: always creates a new array. using the function given as a parameter
- Generates an li tag containing the contents of the note from each note object
notes.map(note =>
  <li key={note.id}>
    {note.content}
  </li>
)

Refactoring Modules: Separate displaying a single note into its own component Note:
- Common practice is to declare each component in its own file as an ES6-module
- Note that the key attribute must now be defined for the Note components, and not for the li tags like before
- The module react-dom/client is assigned to the variable ReactDOM (used to render the React app into the HTML page)
  and the module that defines the main component of the app is placed into the variable App

When the Application Breaks:
- Often happens is that the application just completely breaks down
  This is even more so the case with dynamically typed languages, such as JavaScript, where the compiler does not check the data type
- If the component has been declared as a single statement or a function without a return, it makes printing to the console harder
<!-- const Course = ({ course }) => {  -->
<!--   console.log(course) -->
<!--   return ( -->
<!--     <div> -->
<!--       <Header course={course} /> -->
<!--     </div> -->
<!--   ) -->
<!-- } -->
- Quite often the root of the problem is that the props are expected to be of a different type
  or called with a different name than they actually have, and destructuring fails as a result
  The problem often begins to solve itself when destructuring is removed and we see what the props contain

Web developer's oath:
Programming is hard, that is why I will use all the possible means to make it easier:
- I will have my browser developer console open all the time
- I progress with small steps
- I will write lots of console.log statements to make sure I understand how the code behaves and to help pinpoint problems
- If my code does not work, I will not write more code
  Instead, I start deleting the code until it works or just return to a state when everything was still working
